/**
 * WARNING: DO NOT EDIT THIS FILE OR REMOVE IT FROM YOUR SCRIPTS IF YOU
 * ARE USING THE PARTS-BASED ANIMATION SYSTEM.
 *
 * Docs: https://github.com/todd-roberts/HWPBA
 */

import * as hz from "horizon/core";

/** No-op: brings the system into the world’s scripts. */
export class PartsBasedAnimationSystem extends hz.Component<
  typeof PartsBasedAnimationSystem
> {
  start() {}
}
hz.Component.register(PartsBasedAnimationSystem);

// ---------------- Types ----------------

type QuaternionFrames = number[][];
type Vector3Frames = number[][];

export type AnimationAsset = {
  animations: AnimationData;
  /** Horizon-native vec3 per node (exporter already applied axis mapping) */
  initialPositions: Record<string, number[]>;
  /** Exact prefix added to exported part names (e.g., "Goblin_") */
  namePrefix?: string;
};

export type AnimationData = {
  [animationName: string]: AnimationNodeData;
};

export type AnimationNodeData = {
  times: number[];
  rotations: Record<string, QuaternionFrames>;
  positions: Record<string, Vector3Frames>;
};

export type AnimationPartsNode = { entity: hz.Entity; nodeName: string };

export type AnimatorConfig = {
  animations: AnimationData;
  parts: AnimationPartsNode[];
};

export type AnimationPlayParams = {
  animationName: string;
  speed?: number;
  loop?: boolean;
  callbacks?: { byFrame?: Record<number, () => void>; onEnd?: () => void };
};

type AnimateTransformParams = {
  entity: hz.Entity;
  nodeName: string;
  frameA: number;
  frameB: number;
  interpolationAmount: number;
};

// ---------------- Axis helpers (now identity; exporter is HW-native) ----------------

const quatToHW = (q: QuaternionFrames[0]): hz.Quaternion =>
  new hz.Quaternion(q[0], q[1], q[2], q[3]);

const vec3ToHW = (v: number[]): hz.Vec3 => new hz.Vec3(v[0], v[1], v[2]);

const parentScaleComp = (entity: hz.Entity) => {
  const p = entity.parent.get();
  if (!p) return 1;
  const sx = p.transform.localScale.get().x;
  return 1 / sx;
};

// ---------------- Animator ----------------

class Animator {
  private _animations!: AnimationData;
  private _parts!: AnimationPartsNode[];

  private _animationTime = 0;
  private _currentAnimation: AnimationData[string] | null = null;
  private _currentSpeed = 1;
  private _loop = true;
  private _callbacks: AnimationPlayParams["callbacks"] | undefined = undefined;
  private _triggeredCallbacks = new Set<number>();
  private _pendingPlay: AnimationPlayParams | null = null;

  public configure = (config: AnimatorConfig) => {
    this._animations = config.animations;
    this._parts = config.parts;

    if (this._pendingPlay) {
      const p = this._pendingPlay;
      this._pendingPlay = null;
      this.play(p);
    }
  };

  public isConfigured = () => {
    return Boolean(this._animations);
  };

  public play = (params: AnimationPlayParams) => {
    if (!this._animations) {
      this._pendingPlay = params;
      return;
    }

    const animationName = params.animationName;
    const speed = params.speed === undefined ? 1 : params.speed;
    const loop = params.loop === undefined ? true : params.loop;
    const callbacks = params.callbacks;

    this._animationTime = 0;
    this._triggeredCallbacks.clear();
    this._currentSpeed = speed;
    this._currentAnimation = this._animations[animationName] || null;
    if (!this._currentAnimation) {
      console.warn(
        "[HWPBA] animation not found:",
        animationName,
        "available:",
        Object.keys(this._animations)
      );
    }
    this._loop = loop;
    this._callbacks = callbacks;
  };

  public changeSpeed = (speed: number) => {
    if (this._currentAnimation) this._currentSpeed = speed;
  };

  public stop = () => {
    this._animationTime = 0;
    this._triggeredCallbacks.clear();
    this._currentAnimation = null;
    this._callbacks = undefined;
    this._loop = true;
    this._currentSpeed = 1;
  };

  public update = (deltaTime: number) => {
    if (!this._currentAnimation) return;

    const times = this._currentAnimation.times;
    const animationLength = times[times.length - 1];

    const previousTime = this._animationTime;
    let newTime = this._animationTime + deltaTime * this._currentSpeed;

    if (newTime >= animationLength) {
      if (this._loop) {
        newTime = newTime % animationLength;
        this._triggeredCallbacks.clear();
      } else {
        newTime = animationLength;
        this._animationTime = newTime;
        this.applyFinalFrame();
        const onEnd = this._callbacks ? this._callbacks.onEnd : undefined;
        this.stop();
        if (onEnd) onEnd();
        return;
      }
    }

    this._animationTime = newTime;
    this.checkAndTriggerCallbacks(previousTime, newTime);

    const frames = this.getInterpolationFrames(times);
    const frameA = frames[0];
    const frameB = frames[1];
    const t = this.getInterpolationAmount(times[frameA], times[frameB]);
    this.applyAnimation(frameA, frameB, t);
  };

  private checkAndTriggerCallbacks = (prev: number, curr: number) => {
    if (!this._callbacks || !this._currentAnimation) return;
    const byFrame = this._callbacks.byFrame;
    if (!byFrame) return;

    for (const k in byFrame) {
      const frame = Number(k);
      const time = this._currentAnimation.times[frame];
      if (!this._triggeredCallbacks.has(frame) && time > prev && time <= curr) {
        const fn = byFrame[frame];
        if (fn) fn();
        this._triggeredCallbacks.add(frame);
      }
    }
  };

  private applyFinalFrame = () => {
    const i = this._currentAnimation
      ? this._currentAnimation.times.length - 1
      : 0;
    this.applyAnimation(i, i, 0);
  };

  private getInterpolationFrames = (times: number[]) => {
    if (this._animationTime < times[0]) return [times.length - 1, 0];
    let l = 0;
    let r = times.length - 1;
    while (l <= r) {
      const m = (l + r) >> 1;
      if (times[m] <= this._animationTime) l = m + 1;
      else r = m - 1;
    }
    const a = r < 0 ? 0 : r;
    const b = a + 1 < times.length ? a + 1 : times.length - 1;
    return [a, b];
  };

  private getInterpolationAmount = (a: number, b: number) => {
    const dt = b - a;
    return dt === 0 ? 0 : (this._animationTime - a) / dt;
  };

  private applyAnimation = (frameA: number, frameB: number, t: number) => {
    for (let i = 0; i < this._parts.length; i++) {
      const part = this._parts[i];
      this.applyLocalPosition({
        entity: part.entity,
        nodeName: part.nodeName,
        frameA,
        frameB,
        interpolationAmount: t,
      });
      this.applyLocalRotation({
        entity: part.entity,
        nodeName: part.nodeName,
        frameA,
        frameB,
        interpolationAmount: t,
      });
    }
  };

  private applyLocalPosition = ({
    nodeName,
    frameA,
    frameB,
    interpolationAmount,
    entity,
  }: AnimateTransformParams) => {
    if (!this._currentAnimation) return;
    const partPositions = this._currentAnimation.positions[nodeName];
    if (!partPositions) return;

    const A = partPositions[frameA];
    const B = partPositions[frameB];
    if (!A || !B) return;

    const vA = vec3ToHW(A);
    const vB = vec3ToHW(B);
    let p = hz.Vec3.lerp(vA, vB, interpolationAmount);

    // compensate for *parent* scale
    const k = parentScaleComp(entity);
    if (k !== 1) p = p.mul(k);

    entity.transform.localPosition.set(p);
  };

  private applyLocalRotation = ({
    nodeName,
    frameA,
    frameB,
    interpolationAmount,
    entity,
  }: AnimateTransformParams) => {
    if (!this._currentAnimation) return;
    const partRotations = this._currentAnimation.rotations[nodeName];
    if (!partRotations) return;

    const QA = partRotations[frameA];
    const QB = partRotations[frameB];
    if (!QA || !QB) return;

    const qA = quatToHW(QA);
    const qB = quatToHW(QB);
    const q = hz.Quaternion.slerp(qA, qB, interpolationAmount);
    entity.transform.localRotation.set(q);
  };
}

// ---------------- PB_AnimatedComponent (auto-bind & auto-place) ----------------

type PropsDefinition = {
  animations: { type: typeof hz.PropTypes.Asset };
  visibleAfterLoad: { type: typeof hz.PropTypes.Boolean };
};

export abstract class PB_AnimatedComponent<
  TConstructor extends hz.ComponentWithConstructor<PropsDefinition>
> extends hz.Component<TConstructor> {
  static propsDefinition = {
    animations: { type: hz.PropTypes.Asset },
    /** If true, the entity will be visible after the animations are loaded,
     * regardless of visibility configuration within the editor. */
    visibleAfterLoad: { type: hz.PropTypes.Boolean, default: true },
  };

  protected static withProps = <T extends Record<string, any>>(extra: T) =>
    ({ ...PB_AnimatedComponent.propsDefinition, ...extra } as const);

  private _animator = new Animator();
  private _loaded = false;

  protected onPreStart = () => {};
  protected onUpdate = (_dt: number) => {};

  preStart() {
    this.entity.visible.set(false);
    this.connectLocalBroadcastEvent(hz.World.onUpdate, this.update);
    this.loadAndBind();
    this.onPreStart();
  }

  private collectNodes = (root: hz.Entity): hz.Entity[] => {
    const out: hz.Entity[] = [];
    const stack = root.children.get().slice();
    while (stack.length) {
      const n = stack.pop() as hz.Entity;
      out.push(n);
      const kids = n.children.get();
      if (kids && kids.length) {
        for (let i = 0; i < kids.length; i++) stack.push(kids[i]);
      }
    }
    return out;
  };

  /** Strict: require prefix and strip it. No other normalization. */
  private resolveNodeName = (
    raw: string,
    prefix: string,
    valid: Set<string>
  ): string | null => {
    if (!raw || !prefix) return null;
    if (raw.indexOf(prefix) !== 0) return null;
    const base = raw.slice(prefix.length);
    return valid.has(base) ? base : null;
  };

  private applyInitialPlacement = (
    initialPositions: AnimationAsset["initialPositions"],
    parts: AnimationPartsNode[]
  ) => {
    for (let i = 0; i < parts.length; i++) {
      const entry = parts[i];
      const arr = initialPositions[entry.nodeName];
      if (!arr || arr.length < 3) continue;

      // initialPositions are already Horizon-native; only compensate parent scale
      let v = vec3ToHW(arr);
      const k = parentScaleComp(entry.entity);
      if (k !== 1) v = v.mul(k);

      entry.entity.transform.localPosition.set(v);
    }
  };

  private loadAndBind = async () => {
    if (!this.props.animations) {
      throw new Error(
        "Missing `animations` Text Asset on PB_AnimatedComponent."
      );
    }

    const asset = this.props.animations.as(hz.Asset);
    const data = await asset.fetchAsData();
    if (!data)
      throw new Error(
        "Missing `animations` Text Asset on PB_AnimatedComponent."
      );

    let json: AnimationAsset | null = null;
    try {
      json = data.asJSON<AnimationAsset>();
    } catch (e) {
      json = null;
    }
    if (!json)
      throw new Error(
        "Failed to parse animation JSON. Ensure it matches the HWPBA format."
      );

    const validNames = new Set<string>(
      Object.keys(json.initialPositions || {})
    );
    const prefix = json.namePrefix ? json.namePrefix : "";

    const parts: AnimationPartsNode[] = [];
    const nodes = this.collectNodes(this.entity);
    for (let i = 0; i < nodes.length; i++) {
      const e = nodes[i];
      const raw = e.name.get(); // use each child’s name
      const resolved = this.resolveNodeName(raw, prefix, validNames);
      if (resolved) parts.push({ entity: e, nodeName: resolved });
    }

    this._animator.configure({ animations: json.animations, parts });
    this.applyInitialPlacement(json.initialPositions, parts);
  };

  private update = ({ deltaTime }: { deltaTime: number }) => {
    if (!this._animator.isConfigured()) return;
    if (!this._loaded) {
      if (this.props.visibleAfterLoad) {
        this.entity.visible.set(true);
      }
      this._loaded = true;
    }

    this._animator.update(deltaTime);
    this.onUpdate(deltaTime);
  };

  public playAnimation = (params: AnimationPlayParams) => {
    this._animator.play(params);
  };

  public stopAnimation = () => {
    this._animator.stop();
  };
}
